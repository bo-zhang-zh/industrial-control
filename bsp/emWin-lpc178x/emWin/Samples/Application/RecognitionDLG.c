/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.12                          *
*        Compiled Jun 29 2011, 15:28:47                              *
*        (c) 2011 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
#include "weight.h"
#include "rtthread.h"
#include "TestSlave.h"
#include "canfestival.h"
#include "Slave.h"
#include <dfs_posix.h>
// USER END

#include "DIALOG.h"

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/

#define ID_WINDOW_0 (GUI_ID_USER + 0x00)
#define ID_BUTTON_0 (GUI_ID_USER + 0x01)
#define ID_EDIT_0 (GUI_ID_USER + 0x02)
#define ID_TEXT_0 (GUI_ID_USER + 0x03)
#define ID_BUTTON_1 (GUI_ID_USER + 0x04)
#define ID_BUTTON_2 (GUI_ID_USER + 0x05)
#define ID_BUTTON_3 (GUI_ID_USER + 0x06)
#define ID_BUTTON_4 (GUI_ID_USER + 0x07)
#define ID_BUTTON_5 (GUI_ID_USER + 0x08)
#define ID_BUTTON_6 (GUI_ID_USER + 0x09)
#define ID_BUTTON_7 (GUI_ID_USER + 0x0A)
#define ID_BUTTON_8 (GUI_ID_USER + 0x0B)
#define ID_BUTTON_9 (GUI_ID_USER + 0x0C)
#define ID_BUTTON_10 (GUI_ID_USER + 0x0D)
#define ID_BUTTON_11 (GUI_ID_USER + 0x0E)
#define ID_BUTTON_12 (GUI_ID_USER + 0x0F)

// USER START (Optionally insert additional defines)
#define TRUE    1
#define FALSE   0
#define CANVAS_X_POS   5
#define CANVAS_Y_POS   5
#define CANVAS_X_SIZE   320//128
#define CANVAS_Y_SIZE   320//128

#define MAX_LINE        5
#define MAX_POINT       50

// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
static WM_HWIN hDlg = 0;
static WM_HWIN oldWin;
static FRAMEWIN_Handle hCanvas, hMinImg;
static GUI_MEMDEV_Handle hMem;
static int PointIndex;
static int LinePoint[MAX_POINT][2];

const unsigned char tbl[16] = {0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4};

unsigned char Sample[64] = {0};
unsigned char Digit;
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "Window", ID_WINDOW_0, 1, 0, 800, 480, 0, 0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_0, 683, 364, 92, 40, 0, 0, 0 },
  { EDIT_CreateIndirect, "Edit", ID_EDIT_0, 685, 261, 81, 20, 0, 100, 0 },
  { TEXT_CreateIndirect, "Text", ID_TEXT_0, 641, 263, 39, 20, 0, 100, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_1, 682, 309, 92, 41, 0, 0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_2, 22, 390, 53, 33, 0, 0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_3, 89, 394, 49, 33, 0, 0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_4, 151, 394, 51, 32, 0, 0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_5, 221, 395, 49, 30, 0, 0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_6, 282, 392, 51, 37, 0, 0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_7, 19, 430, 53, 37, 0, 0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_8, 84, 432, 53, 35, 0, 0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_9, 145, 433, 58, 33, 0, 0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_10, 216, 433, 51, 32, 0, 0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_11, 281, 434, 51, 34, 0, 0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_12, 684, 427, 92, 34, 0, 0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
static void SendSample(void)
{
	int i;
	for(i=0; i<64; i++)
	{
		//rt_kprintf("%d,", Sample[i]);
		//printf("%d,", Sample[i]);
	}
	//rt_kprintf("%d\r\n", Digit);
	//printf("%d\r\n", Digit);
}

static void logsig(float Data, float *pResult)
{
	extern const float logsigTbl[1001];
	int index;
	float tmp1,tmp2;
	if (Data >= 0)
	{
		if (Data > 10)
		{
			*pResult = logsigTbl[1000];
		}
		else
		{
			index = (int)(Data * 100);
			tmp1 = (float)index / 100;
			tmp2 = ((float)index + 1) / 100;
			*pResult = (Data - tmp1) / (tmp2 - tmp1) * (logsigTbl[index+1] - logsigTbl[index]) + logsigTbl[index];
		}
	}
	else
	{
		if (Data < -10)
		{
			*pResult = 1 - logsigTbl[1000];
		}
		else
		{
			Data = -Data;
			index = (int)(Data * 100);
			tmp1 = (float)index / 100;
			tmp2 = ((float)index + 1) / 100;
			Data = (Data - tmp1) / (tmp2 - tmp1) * (logsigTbl[index+1] - logsigTbl[index]) + logsigTbl[index];
			*pResult = 1 - Data;
		}
	}
}


static void ConvertToResult(const U8 *sam, U8 *reslut)
{
//	extern const float logsig[1001];
	int i, j;
	int index;
//	float tmp1,tmp2;
	char cResult[3] = {0};
	float HiddenOut[25] = {0};
	float NetworkOut[10] = {0};
	WM_HWIN hItem;

	for (i=0; i<25; i++)
	{
		for (j=0; j<64; j++)
		{
			HiddenOut[i] += WihTbl[i][j] * sam[j];
		}
		HiddenOut[i] += BihTbl[i];
	}

	for (i=0; i<25; i++)
	{
		logsig(HiddenOut[i], &HiddenOut[i]);
	}

	for (i=0; i<10; i++)
	{
		for (j=0; j<25; j++)
		{
            NetworkOut[i] += WhoTbl[i][j] * HiddenOut[j];
		}
		NetworkOut[i] += BhoTbl[i];
	}

	for (i=0; i<10; i++)
	{
		logsig(NetworkOut[i], &NetworkOut[i]);
	}

	index = 0;
	for (i=1; i<10; i++)
	{
		if (NetworkOut[i] > NetworkOut[index])
		{
			index = i;
		}
	}
	Digit = index;
	hItem = WM_GetDialogItem(hDlg, ID_EDIT_0);
	cResult[0] = index + '0';
    EDIT_SetText(hItem, cResult);
}


static void ConvertToStd(int x1, int y1, int x2, int y2)
{
  int xSize, ySize, x, y, Offset, Bit;
	int xMin, yMin, k = 0, m = 0;
	U8 buf[128] = {0};
//	U8 sample[64] = {0};
	int Idx = 0, bitIdx = 0;
	U8 data;//,tmp;
	U8* pData;
	GUI_COLOR colorPre = GUI_GetColor();
   
	WM_SelectWindow(hMinImg);
  /* Get the size of the memory device */
  xSize = GUI_MEMDEV_GetXSize(hMem);
  ySize = GUI_MEMDEV_GetYSize(hMem);
  pData = (U8 *)GUI_MEMDEV_GetDataPtr(hMem); /* Get the data pointer of the memory device */
 
  /* Draw the pixels of the memory device on the screen */
  for (y = 0, yMin = 0; y < ySize; y += CANVAS_Y_SIZE/32, yMin++) {
    for (x = 0, xMin = 0; x < xSize; x += CANVAS_X_SIZE/32, xMin++) {
      U8 Index;
      Offset = x >> 3;
      Bit    = 7 - (x & 7);
      Index  = *(pData + Offset);
      Index &= (1 << Bit);
      /* The index could be 0 or 1, so use black and white */
      if (Index == 0 ) {
        GUI_SetColor(GUI_BLACK);
		buf[Idx] |= 1 << bitIdx;
		bitIdx++;
		if (bitIdx > 7){
		  Idx++;
		  bitIdx = 0;
		}
      } else {
        GUI_SetColor(GUI_WHITE);
		buf[Idx] &= ~(1 << bitIdx);
		bitIdx++;
		if (bitIdx > 7){
			Idx++;
			bitIdx = 0;
		}
      }
       /* Draw the pixel. At this point for example a printer output routine can be called */              
      GUI_DrawPixel(xMin, yMin);
    }
    pData += (xSize + 7) / 8 * (CANVAS_X_SIZE/32);
	if (bitIdx > 0)
	{
		Idx++;
		bitIdx = 0;
	}
  }

  Idx = 0;
  for (y=0; y < 32; y += 4){
	for (x=0; x < 32 / 8; x++)
	{
      data = buf[y*4+x] & 0x0f;
	  Sample[Idx] = tbl[data];
	  data = buf[(y+1)*4+x] & 0x0f;
	  Sample[Idx] += tbl[data];
	  data = buf[(y+2)*4+x] & 0x0f;
	  Sample[Idx] += tbl[data];
	  data = buf[(y+3)*4+x] & 0x0f;
	  Sample[Idx] += tbl[data];
	  Idx++;
      data = buf[y*4+x] >> 4;
	  Sample[Idx] = tbl[data];
	  data = buf[(y+1)*4+x] >> 4;
	  Sample[Idx] += tbl[data];
	  data = buf[(y+2)*4+x] >> 4;
	  Sample[Idx] += tbl[data];
	  data = buf[(y+3)*4+x] >> 4;
	  Sample[Idx] += tbl[data];
	  Idx++;
	}
  }
  ConvertToResult(Sample, &data);

	WM_SelectWindow(hCanvas);
  GUI_SetColor(colorPre);
  
//	GUI_MEMDEV_Select(hMem);
}

void RedrawInMem(int pt[][2], int numPt)
{
	int k = 0;
	int xSize, ySize, i, num, xOffset, yOffset, width;
	float xMag, yMag;
	int bNew = 2, bPre = 2;
	int x1, x2, y1, y2;
	int tmp1, tmp2;
    unsigned char  * pData;
	num = numPt;
//	WM_SelectWindow(hMinImg);
	hMem = GUI_MEMDEV_CreateFixed(0, 0, CANVAS_X_SIZE, CANVAS_Y_SIZE, 
	                            	0,//GUI_MEMDEV_NOTRANS, 
	                               	GUI_MEMDEV_APILIST_1, /* Used API list */
                                    GUI_COLOR_CONV_1);    /* Black/white color conversion */
	WM_SelectWindow(oldWin);
    GUI_MEMDEV_Select(hMem);
	xSize = GUI_MEMDEV_GetXSize(hMem);
    ySize = GUI_MEMDEV_GetYSize(hMem);
    pData = (unsigned char *)GUI_MEMDEV_GetDataPtr(hMem);
	for (i=0; i < (xSize+7) / 8 * ySize; i++)
	{
		*pData++ = 255;
	}

	
	num = numPt;
	if (pt[0][0] < 0){
		tmp1 = -pt[0][0];
		tmp2 = -pt[0][1];
	}else{
		tmp1 = pt[0][0];
		tmp2 = pt[0][1];
	}
	x1 = x2 = tmp1;
	y1 = y2 = tmp2;
	k = 1;
	num--;
	while (num)
	{
		if ((pt[k][0]==0) && (pt[k][1]==0))
		{
			break;
		}
		if (pt[k][0] < 0){
			tmp1 = -pt[k][0];
			tmp2 = -pt[k][1];
		}else{
			tmp1 = pt[k][0];
			tmp2 = pt[k][1];
		}
		if (tmp1 < x1){
			x1 = tmp1;
		}
		if (tmp2 < y1){
			y1 = tmp2;
		}
		if (tmp1 > x2){
			x2 = tmp1;
		}
		if (tmp2 > y2){
			y2 = tmp2;
		}
		k++;
		num--;
	}
	xOffset = CANVAS_X_POS + CANVAS_X_SIZE / 2 - (x1 + (x2 - x1) / 2);
	yOffset = CANVAS_Y_POS + CANVAS_Y_SIZE / 2 - (y1 + (y2 - y1) / 2);
	for (k = 0; k < numPt; k++)
	{
		if (pt[k][0] < 0){
			pt[k][0] = pt[k][0] - xOffset;
			pt[k][1] = pt[k][1] - yOffset;
		}else{
			pt[k][0] = pt[k][0] + xOffset;
			pt[k][1] = pt[k][1] + yOffset;
		}
	}
// 	x1 += xOffset;
// 	y1 += yOffset;
// 	x2 += xOffset;
// 	y2 += yOffset;
// 
	x1 = x1 - 8 - CANVAS_X_POS;//Pen Size is 20
	x2 = x2 + 8 - CANVAS_X_POS;
	y1 = y1 - 8 - CANVAS_Y_POS;
	y2 = y2 + 8 - CANVAS_Y_POS;
	if (x1 < 0)
		x1 = 0;
	if (y1 < 0)
		y1 = 0;

	if (x2 > CANVAS_X_SIZE)
		x2 = CANVAS_X_SIZE;
	if (y2 > CANVAS_Y_SIZE)
		y2 = CANVAS_Y_SIZE;
// 	if (x2-x1 > y2-y1)
// 	{
// 		if (y2 + (x2-x1-y2+y1)/2 > CANVAS_Y_SIZE){
// 			y2 = CANVAS_Y_SIZE;
// 			y1 = y2 - (x2 - x1);
// 		}else if (y1 - (x2-x1-y2+y1)/2 < 0){
// 			y1 = 0;
// 			y2 = x2 - x1;
// 		}else{
// 			y1 = y1 - (x2-x1-y2+y1)/2;
// 			y2 = y2 + (x2-x1-y2+y1)/2;
// 		}
// 	}else{
// 		if (x2 + (y2-y1-x2+x1)/2 > CANVAS_X_SIZE){
// 			x2 = CANVAS_X_SIZE;
// 			x1 = x2 - (y2 - y1);
// 		}else if (x1 - (y2-y1-x2+x1)/2 < 0){
// 			x1 = 0;
// 			x2 = y2 - y1;
// 		}else{
// 			x1 = x1 - (y2-y1-x2+x1)/2;
// 			x2 = x2 + (y2-y1-x2+x1)/2;
// 		}
// 	}
// 	x1 += CANVAS_X_POS;
// 	x2 += CANVAS_X_POS;
// 	y1 += CANVAS_Y_POS;
// 	y2 += CANVAS_Y_POS;
	if (x2-x1 > y2-y1)
	{
		width = x2 - x1;
	} 
	else
	{
		width = y2 - y1;
	}
	xMag = (float)CANVAS_X_SIZE / width;
	yMag = (float)CANVAS_Y_SIZE / width;
	for (k=0; k<numPt; k++)
	{
		if (pt[k][0] < 0){
			pt[k][0] = -(CANVAS_X_SIZE / 2 - (int)((CANVAS_X_SIZE / 2 + pt[k][0] + CANVAS_X_POS) * xMag));
			pt[k][1] = -(CANVAS_Y_SIZE / 2 - (int)((CANVAS_Y_SIZE / 2 + pt[k][1] + CANVAS_Y_POS) * yMag));
		}else{
			pt[k][0] = CANVAS_X_SIZE / 2 - (int)((CANVAS_X_SIZE / 2 - pt[k][0] + CANVAS_X_POS) * xMag);
			pt[k][1] = CANVAS_Y_SIZE / 2 - (int)((CANVAS_Y_SIZE / 2 - pt[k][1] + CANVAS_Y_POS) * yMag);
		}
	}


	num = numPt;
	k = 0;
	while (num) 
	{
         if (pt[k][0] > 0)
         {
			 bNew = 1;
			 if (bNew != bPre)
			 {
				 GUI_MoveTo(pt[k][0], pt[k][1]);
				 bNew = FALSE;
			 }
			 else
			 {
				 GUI_DrawLineTo(pt[k][0], pt[k][1]);
			 }
			 bPre = 1;
			 k++;
         } 
         else
         {
			 bNew = 0;
			 if (bNew != bPre)
			 {
				 GUI_MoveTo(-pt[k][0], -pt[k][1]);
				 bNew = FALSE;
			 }
			 else
			 {
				 GUI_DrawLineTo(-pt[k][0], -pt[k][1]);
			 }
			 bPre = 0;
			 k++;
         }
		 num--;
	}

    ConvertToStd(x1, y1, x2, y2);

	GUI_MEMDEV_Delete(hMem);
	GUI_MEMDEV_Select(0);
	WM_SelectWindow(hCanvas);
}



// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int Id, NCode;
  // USER START (Optionally insert additional variables)
  char cTxt[4] = {0};
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_0);
    BUTTON_SetText(hItem, "Convert");
    //
    // Initialization of 'Text'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);
    TEXT_SetText(hItem, "Result:");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_1);
    BUTTON_SetText(hItem, "Clear");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_2);
    BUTTON_SetText(hItem, "0");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_3);
    BUTTON_SetText(hItem, "1");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_4);
    BUTTON_SetText(hItem, "2");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_5);
    BUTTON_SetText(hItem, "3");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_6);
    BUTTON_SetText(hItem, "4");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_7);
    BUTTON_SetText(hItem, "5");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_8);
    BUTTON_SetText(hItem, "6");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_9);
    BUTTON_SetText(hItem, "7");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_10);
    BUTTON_SetText(hItem, "8");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_11);
    BUTTON_SetText(hItem, "9");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_12);
    BUTTON_SetText(hItem, "Send");
    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_BUTTON_0: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		  RedrawInMem(LinePoint, PointIndex);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_EDIT_0: // Notifications sent by 'Edit'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_1: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
			cmd++;
			//rt_kprintf("send cmd\n");
			//sendOnePDOevent (&TestSlave_Data, 0x01);
			WriteSDO(MASTER_NODEID, 0x2003, 0x00, 1, uint8, &cmd);
		  WM_SelectWindow(hMinImg);
		  GUI_Clear();
		  WM_SelectWindow(hCanvas);
		  GUI_Clear();
		  PointIndex = 0;
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_2: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		  Digit = 0;
		  cTxt[0] = Digit + '0';
		  hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
		  EDIT_SetText(hItem, cTxt);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_3: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		  Digit = 1;
		  cTxt[0] = Digit + '0';
		  hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
		  EDIT_SetText(hItem, cTxt);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_4: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		  Digit = 2;
		  cTxt[0] = Digit + '0';
		  hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
		  EDIT_SetText(hItem, cTxt);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_5: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		  Digit = 3;
		  cTxt[0] = Digit + '0';
		  hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
		  EDIT_SetText(hItem, cTxt);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_6: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		  Digit = 4;
		  cTxt[0] = Digit + '0';
		  hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
		  EDIT_SetText(hItem, cTxt);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_7: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		  Digit = 5;
		  cTxt[0] = Digit + '0';
		  hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
		  EDIT_SetText(hItem, cTxt);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_8: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		  Digit = 6;
		  cTxt[0] = Digit + '0';
		  hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
		  EDIT_SetText(hItem, cTxt);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_9: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		  Digit = 7;
		  cTxt[0] = Digit + '0';
		  hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
		  EDIT_SetText(hItem, cTxt);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_10: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		  Digit = 8;
		  cTxt[0] = Digit + '0';
		  hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
		  EDIT_SetText(hItem, cTxt);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_11: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		  Digit = 9;
		  cTxt[0] = Digit + '0';
		  hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
		  EDIT_SetText(hItem, cTxt);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_12: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		  SendSample();
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateWindow
*/
WM_HWIN CreateWindow(void);
WM_HWIN CreateWindow(void) {
  WM_HWIN hWin;

  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), &_cbDialog, WM_HBKWIN, 1, 0);
  return hWin;
}

// USER START (Optionally insert additional public code)

UNS32 TestSlave_obj2003_callback(CO_Data* d, const indextable *od_entry, UNS8 bSubindex)
{
	GUI_SetBkColor(GUI_WHITE);
	WM_SelectWindow(hMinImg);
	GUI_Clear();
	WM_SelectWindow(hCanvas);
	GUI_Clear();
	PointIndex = 0;
	
	rt_kprintf("Clear the screen!!\n");
	return OD_SUCCESSFUL;
}

int RecvFile = 0;
/*********************************************************************
*
*       MainTask
*/
void MainTask(void);
void MainTask(void) {
  int bFirstPoint = TRUE;
  int bNextLine = FALSE;
  int _xPos = 0, _yPos = 0;
  GUI_PID_STATE tchPos;
	
	int fd;
	UNS8 *pBuf;
	UNS32 errorCode;
  const indextable *ptrTable;
  ODCallback_t *Callback;
	
	
  PointIndex = 0;
	
  WM_SetCreateFlags(WM_CF_MEMDEV);
  GUI_Init();
//  #if GUI_SUPPORT_CURSOR
//    GUI_CURSOR_Show();
//  #endif
  oldWin = WM_SelectWindow(WM_HBKWIN);
  WM_SetDesktopColor(GUI_BLACK);
//  #if GUI_SUPPORT_MEMDEV
    
//  #endif
 

  hDlg = CreateWindow();
  hCanvas = WM_CreateWindowAsChild(CANVAS_X_POS, CANVAS_Y_POS, CANVAS_X_SIZE, CANVAS_Y_SIZE, 
	                                 hDlg, WM_CF_SHOW | WM_CF_STAYONTOP, 0, 0);
  hMinImg = WM_CreateWindowAsChild(CANVAS_X_POS + CANVAS_X_SIZE + 10, 10, 32, 32, hDlg, WM_CF_SHOW | WM_CF_STAYONTOP, 0, 0);
  WM_SelectWindow(hMinImg);
  GUI_SetBkColor(GUI_WHITE);
  GUI_Clear();
  WM_SelectWindow(hCanvas);
  GUI_Clear();
  GUI_SetColor(GUI_BLUE);
  GUI_SetPenSize(20);

 // GUI_MEMDEV_Select(0);
//  GUI_DrawRect(5, 5, 5+128, 5+128);
  while (1) {
		
		if (RecvFile == 1)
		{
			RecvFile = 0;
			
			ptrTable =(TestSlave_Data.scanIndexOD)(0x2004, &errorCode, &Callback);
			pBuf = (UNS8*)ptrTable->pSubindex[0].pObject;
			if (pBuf == RT_NULL)
				continue;
			rt_kprintf("store file\n");
			fd = open(FileName, O_WRONLY | O_CREAT | O_TRUNC, 0);
			if (fd >= 0)
			{
				write(fd, pBuf, FileSize);
				close(fd);
				rt_kprintf("store file successfully\n");
			}
			else
			{
				rt_kprintf("store file failed\n");
			}
			
			rt_free(pBuf);

			ptrTable->pSubindex[0].pObject = 0;
			ptrTable->pSubindex[0].size = 0;

		}
	if (GUI_TOUCH_GetState(&tchPos) && PointIndex < MAX_POINT)
	{
		xPos = tchPos.x;
		yPos = tchPos.y;
		Pressed = 1;
	  if (bFirstPoint)
	  {
		  _xPos = tchPos.x;
		  _yPos = tchPos.y;
		  if ((_xPos >= CANVAS_X_POS) && (_xPos <= CANVAS_X_POS+CANVAS_X_SIZE) 
				     && (_yPos >= CANVAS_Y_POS) && (_yPos <= CANVAS_Y_POS+CANVAS_Y_SIZE))
			{
			  GUI_MoveTo(tchPos.x, tchPos.y);
				//rt_kprintf("Start: %d, %d\n", tchPos.x, tchPos.y);
			  bFirstPoint = FALSE;
			  bNextLine = !bNextLine;
			  if (bNextLine)
			  {
          LinePoint[PointIndex][0] = tchPos.x;
          LinePoint[PointIndex][1] = tchPos.y;
			  }
			  else
			  {
				  LinePoint[PointIndex][0] = -tchPos.x;
          LinePoint[PointIndex][1] = -tchPos.y;
			  }
			  PointIndex++;
			}
	  }
	  else
	  {
		  if (tchPos.x != _xPos  || tchPos.y != _yPos)
		  {
		    if ((_xPos >= CANVAS_X_POS) && (_xPos <= CANVAS_X_POS+CANVAS_X_SIZE) 
				     && (_yPos >= CANVAS_Y_POS) && (_yPos <= CANVAS_Y_POS+CANVAS_Y_SIZE))
			  {
			    GUI_DrawLineTo(tchPos.x, tchPos.y);
					//rt_kprintf("Next: %d, %d\n", tchPos.x, tchPos.y);
				  if (bNextLine)
				  {
					  LinePoint[PointIndex][0] = tchPos.x;
					  LinePoint[PointIndex][1] = tchPos.y;
				  }
				  else
				  {
					  LinePoint[PointIndex][0] = -tchPos.x;
					  LinePoint[PointIndex][1] = -tchPos.y;
				  }
				  PointIndex++;
					//GUI_MoveTo(xPos, yPos);
					//GUI_MEMDEV_Select(0);
					//GUI_DrawLineTo(tchPos.x, tchPos.y);
					//GUI_MEMDEV_Select(hMem);
					//GUI_DrawPoint(tchPos.x, tchPos.y);
			  }
		  	_xPos = tchPos.x;
		  	_yPos = tchPos.y;
		  }
	  }
	}
	else
	{
		xPos = -1;
		yPos = -1;
		Pressed = 0;
		
	  bFirstPoint = TRUE;
	}

	sendPDOevent(&TestSlave_Data);
	GUI_Delay(20);
    //GUI_Exec();
  }
}
// USER END

/*************************** End of file ****************************/
